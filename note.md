# 什么是设计模式？

设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。

# 设计模式的目的

使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络。

# 模式是什么？

模式是指从生产经验和生活经验中经过抽象和升华提炼出来的核心知识体系。其实就是解决某一类问题的方法论。

# 设计模式的六大原则

减少耦合，增强复用性，减低代码的开发维护扩展成本。

耦合关系是指某两个事物之间如果存在一种相互作用、相互影响的关系，这种关系就成为耦合关系。

## 耦合度和复杂度的危害

复杂度：高，代码质量不高，可维护性差，复用性差，不易扩展。

耦合度：无不可能，低合理，过高不容易维护。单复用性和扩展性是好的。

## 开发时的流程

优先降低复杂度，尽量降低耦合度

1.利用单一职责原则，开闭原则，里氏代换原则降低复杂度

2.通过迪米特法则减少耦合

3.通过依赖倒置原则消除可以没有的耦合

先靠单一 开闭 里氏给它分成很多块，最小知道让他们关系变弱化，最后需要依赖倒置把没必要的

## 单一职责原则

一个方法只做一件事

## 开闭原则

一个软件实体如类、模块和函数应该对扩展开放，对修改关闭，同时增强代码复用性。

## 里氏代换原则

任何基类可以出现的地方，子类一定可以出现。通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。

## 接口分离原则

把大接口拆分成小接口，不能一个接口全部实现增删改查。

## 迪米特法则（最小知道原则）

一个接口（js中没有接口概念）和一个方法，传入的参数越少越好。降低耦合度的同时也会让复杂度降低，形成的关联越少越好，依赖最少。

## 依赖倒置原则

最常用的原则，依赖接口，不依赖方法，底层的东西不要了解，我们只需知道表现就可以，降低耦合度，前端应用可以理解多着之间依赖状态，而不依赖彼此。



# 设计模式

## 单例模式

保证一个类仅有一个实例并提供一个访问它的全局访问点。

在它的核心结构中只有一个被称为单例的特殊类。通常单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。

## 代理模式

为一个对象提供一种代理以控制对这个对象的访问。

代理对象起到类似中介的作用，会增加一些功能（如校验，合并等等），也会去掉一些原有的功能。

虚拟代理： 把一些开销很大的对象，延迟但真正需要它的时候才去创建执行。（图片加载，文件上传）

安全代理： 控制真实对象的访问权限。（登录操作后才能看全功能，全段校验）

远程代理： 一个对象将不同控件的对象进行局部代理。（监控多个对象的状态，总机监控分店）

智能代理：调用对象代理处理另外一些事情如垃圾回收机制增加额外的服务。（提供额外的其他服务，火车站代收处）

## 工厂模式

工厂模式定义创建对象的接口，但是让子类去真正的实例化。也就是工厂方法将类的实例化延迟到子类。

### 对比其他方式

1. 工厂类集中了所有对象的创建，便于对象创建的统一管理
2. 对象的使用者仅仅是使用产品，实现了单一职责
3. 便于扩展，如果新增一种业务，只需要增加相关的业务对象类和工厂类中的生产业务对象的方法，不需要修改其他的地方
4. 确实违反了开闭原则

### 工厂方法模式

#### 定义

不再有一个唯一的工厂类就创建产品，而是将不同的产品交给对应的工厂子类去实现。每个产品由负责生产的子工厂来创造。如果添加新的产品，需要做的是添加新的子工厂和产品，而不需要修改其他的工厂代码。

#### 组成

1. 抽象工厂类： 负责定义创建产品的公共接口。
2. 产品子工厂：继承抽象工厂类，实现抽象工厂类提供的接口。
3. 每一种产品有各自的产品类。

#### 总结

代码比简单工厂模式复杂了，引入了抽象层，还有子工厂，这会增加代码的复杂度和理解难度。但是相比于简单工厂模式，代码的维护性和扩展性提高了，新增产品时，只需要增加对应的产品类和产品工厂类。更加符合面向对象的开放封闭原则。

当然具体场景具体分析，复杂性和扩展性相比如何舍弃，在使用的时候要结合实际场景去分析。

## 装饰者模式

在不改变对象的基础上，通过对其进行包装扩展（添加属性方法）。

装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。可以在脚本运行时，在子类中增加行为去影响原有类所有的实例，而装饰者却不然，给不同对象各自添加新行为和属性。

实现：构造函数需要一个装饰资源池，提供相应的装饰方法，提供添加装饰方法的方法。

## 观察者模式（发布订阅模式）

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知。例如，在DOM节点上绑定事件

